<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Computer Science Fundamentals</title>
<meta name="author" content="(Detroit Labs Dev Coaching)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/league.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>
<link rel="stylesheet" href="./reveal.js/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Computer Science Fundamentals</h1><h2 class="author">Detroit Labs Dev Coaching</h2><h2 class="date">2018</h2>
</section>

<section>
<section id="slide-org9fc9424">
<h2 id="org9fc9424">Lecture 1</h2>
<aside class="notes">
<ul>
<li>What does data look like to a computer</li>
<li>What do programs look like to a computer</li>
<li>How does the representation of data relate to how computers process data</li>
<li>Basically, computers are dumb</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org792d96b">
<h2 id="org792d96b">What Does Data Look Like?</h2>
<div class="outline-text-2" id="text-org792d96b">
</div>
</section>
<section id="slide-orga7ecb5f">
<h3 id="orga7ecb5f"><img src="https://upload.wikimedia.org/wikipedia/commons/3/3c/DDR_RAM-3.jpg" alt="DDR_RAM-3.jpg" /></h3>
<aside class="notes">
<ul>
<li>You're probably familiar with one of these ­ a RAM module.</li>
<li>This is what most people think of when we think of "storing data
in the computer"</li>
<li>But how does RAM store data? How do we get data in and out of
there?</li>
<li>In the case of RAM, these chips store electricity in different
parts of the chip to represent data</li>

</ul>

</aside>
</section>
<section id="slide-org18cd011">
<h3 id="org18cd011"><img src="https://upload.wikimedia.org/wikipedia/commons/9/90/Hard_Drive_(11644419853).jpg" alt="Hard_Drive_(11644419853).jpg" /></h3>
<aside class="notes">
<ul>
<li>Or you might think of one of these ­ a hard drive</li>
<li>At least this is what most hard drives looked like before the
prevalence of solid state drives</li>
<li>Here, minuscule points along the stripes of the platter are
magnetized either positively or negatively to represent data</li>

</ul>

</aside>
</section>
<section id="slide-org5f8158e">
<h3 id="org5f8158e">What does "It's all just ones and zeros" mean?</h3>
<aside class="notes">
<ul>
<li>How do we get from a spark of electricity to data we can relate to?</li>
<li>No doubt you've heard "it's all just ones and zeros" bandied
about, but what does that mean? How do we get numbers and text
and graphics and movies from ones and zeros?</li>
<li>We call these ones and zeros "bits" and they are the fundamental
element of how we represent data in the computer</li>

</ul>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="100%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="https://cdn.pixabay.com/photo/2013/10/15/03/40/sparks-195834_960_720.jpg" alt="sparks-195834_960_720.jpg" /></td>
<td class="org-left"><img src="https://c1.staticflickr.com/9/8016/7317420838_edb29a4043_b.jpg" alt="7317420838_edb29a4043_b.jpg" /></td>
</tr>
</tbody>
</table>
</section>
<section id="slide-orgedda58a">
<h3 id="orgedda58a">A Bit as a Lightbulb</h3>
<aside class="notes">
<ul>
<li>One way to help grok how computers keep track of data is to think
of a bit as a light bulb</li>
<li>If the light is off, we can think of it as a 0</li>
<li>If the light is on, we can think of it as a 1</li>
<li>Once we've turned a light on or off, if we forget whether it was
a 0 or a 1, we can look back at the bulb and see if the light is on</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Carbonfilament.jpg/279px-Carbonfilament.jpg" alt="279px-Carbonfilament.jpg" />
</p>
</div>
</section>
<section id="slide-org319b1c2">
<h3 id="org319b1c2">What is a Bit?</h3>
<aside class="notes">
<ul>
<li>The word "bit" is a portmanteau of "binary" and "digit"</li>
<li>A bit is the smallest value we can usefully represent</li>
<li>We could have built computers to run on human decimal digits 0-9,
but then a computer would need to be significantly more
complicated at its fundamental level</li>
<li>This is a Difference Engine designed by Charles Babbage for
solving polynomial functions capable of calculating with 6-digit
numbers up to second-order polynomials.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1d/Charles_Babbage_Difference_Engine_No1.jpg" alt="Charles_Babbage_Difference_Engine_No1.jpg" height="50%," width="50%" />
</p>
</div>
</section>
<section id="slide-orgd9e5574">
<h3 id="orgd9e5574">How About Many Bits?</h3>
<aside class="notes">
<ul>
<li>So if all we can store are ones and zeros, how do we get all that
other stuff?</li>
<li>By adding implicit meaning into series of consecutive ones and
zeros, we can encode more complex ideas into bits without
increasing the complexity of the mechanisms needed to store them</li>
<li>For example, if we wanted to interpret these light bulbs as
binary numbers, with the first light representing the 1's digit,
the next light representing the 2's, the third representing the
4's digit, and the last representing the 8's, we can read these
lights as either a 5 or a 10, depending on the ordering we
interpret them in. This still allows us 16 possible values by
storing only 4 pieces of simple information.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://noschese180.files.wordpress.com/2013/05/imag21611.jpg" alt="imag21611.jpg" />
</p>
</div>
</section>
<section id="slide-org66a253e">
<h3 id="org66a253e">Encoding Data</h3>
<aside class="notes">
<ul>
<li>For practical purposes, we can call interpreting series of bits
in different ways as encoding.</li>
<li>For example, instead of a binary number, we could say that series
of bits might represent a pixel, with the A position for red,
B representing green, and C representing blue, and D representing
a flag for whether or not this is a pixel or not. This gives us a
total of 8 color combinations, but also the ability to interpret
the other 3 bits as something else entirely.</li>
<li>By combining arbitrary numbers of bits, we can represent any data
we want as a series of on-off statements</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://i.imgur.com/Aluf9RK.png" alt="Aluf9RK.png" />
</p>
</div>
</section>
<section id="slide-orge2e6372">
<h3 id="orge2e6372"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Z3_Deutsches_Museum.JPG/1280px-Z3_Deutsches_Museum.JPG" alt="1280px-Z3_Deutsches_Museum.JPG" /></h3>
<aside class="notes">
<ul>
<li>This is the Zuse Z3, the world's first working electromechanical
programmable, fully automatic digital computer.</li>
<li>It was built with 2000 relays, and which relays were in the "on"
position versus the "off" position kept track of the
representation of the data it was working with.</li>
<li>The move from Babbage's decimal digits to binary digits meant that
reliable computers which could model more diverse types of data
could be built from mostly commodity components.</li>
<li>Although the Zuse Z3 read its programs from tape, Zuse predicted
the versatility of binary digits and patented the idea of program
data also being representable as part of the computer's memory.</li>

</ul>

</aside>
</section>
<section id="slide-org5909966">
<h3 id="org5909966">What is a Byte?</h3>
<aside class="notes">
<ul>
<li>So back to bits&#x2026; we know that series of bits are more valuable
to us than single on/off or true/false values.</li>
<li>The standard way we generally refer to groups of bits is the
byte, a unit composed of 8 bits.</li>
<li>A byte gives us 256 possible combinations of bits, and allows for
the modeling of quite a few things - for example the numbers
between -128 and 127, or more than enough room to store every
character that it's possible to type on a standard American
keyboard.</li>
<li>So for example, this byte is the number 45, which we could
interpret as just the number 45, or as the hyphen character if
we're interpreting it as text.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f5/Byte45.png" alt="Byte45.png" />
</p>
</div>
</section>
<section id="slide-org4d9a998">
<h3 id="org4d9a998">What's in a Memory Address</h3>
<aside class="notes">
<ul>
<li>Since we now have a lot of bytes to keep track of, I'm sure you
can guess that we can pull the same trick and use series of bytes
in the same way we use series of bits, and by combining arbitrary
bytes in various orders we can model almost anything we'd like.</li>
<li>So if we want to have many bytes, we probably need a way to get
at all those bytes. Enter: the memory address.</li>
<li>A memory address is a number designating a particular byte we
would like to look at.</li>
<li>The addressable memory space in most modern computers correlates
to the "word length" of processors - that's the 32-bit or 64-bit
designation related to your processor. While this isn't
necessarily true, as word length and address size are not always
the same, it's generally true.</li>
<li>In 32 bits, there are 2<sup>32</sup> or 4,294,967,296 combinations, and
therefore that many addresses. We keep one byte at each address,
giving us a maximum of 4GB of addressable memory.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/2000px-Little-Endian.svg.png" alt="2000px-Little-Endian.svg.png" height="50%," width="50%" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-orgd4e5b8f">
<h2 id="orgd4e5b8f">What Do Programs Look Like?</h2>
<aside class="notes">
<ul>
<li>Now that we know all that, we'll be switching it up for a
moment.</li>
<li>Generally, we don't just want a computer to store data, we want a
computer to do something with that data.</li>
<li>Now that we understand roughly how a computer stores data at a
fundamental level, we should try to get a grasp of what we do in
code does on a fundamental level.</li>

</ul>

</aside>
</section>
<section id="slide-orga50f1b7">
<h3 id="orga50f1b7">What does a Line of Code Look Like?</h3>
<aside class="notes">
<ul>
<li>So what does a line of code look like?</li>
<li>We probably think of these as single actions.</li>
<li>In truth, each of these lines of code translates to a different
number of operations that need to be performed by the processor.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >int a = 1;
int b = a;
int c = a + b;
</code></pre>
</div>
</section>
<section id="slide-org36fd711">
<h3 id="org36fd711">What is in a Line of Code?</h3>
<aside class="notes">
<ul>
<li>While we are learning C, which we think of as a "low-level"
language, it's important to remember that the code we write is
still translated into more and more primitive code as it talks to
the hardware.</li>
<li>The following line of C code actually generates the line of
assembly shown after it. Notice that it is "moving" the value 1
onto the double-word (32-bit) length pointer 4 bytes before the
end address of the program's allocated memory space.</li>
<li>This generated assembly is a set of instructions for the
processor on what to actually do with the hardware. The computer
does not know or care what an A is, and for that matter doesn't
even really know what an integer is. DWORD here is simply a human
shortcut that means "4 bytes".</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >int a = 1;
</code></pre>
</div>
<div class="org-src-container">

<pre><code class="asm" >mov DWORD PTR [rbp-4], 1
</code></pre>
</div>
</section>
<section id="slide-org95d0d22">
<h3 id="org95d0d22">What does a Program Look Like?</h3>
<aside class="notes">
<ul>
<li>Here is a simple C program. All it does is allocate 3
integers. The first is a 1. The second is a copy of that
same 1. The third is the result of adding those ones together.</li>
<li>The return 0 at the end is not necessary, as 0 would be the
implicit exit code of the program, but otherwise, there is no
output, the computer simply adds the two numbers together and
then does nothing.</li>
<li>So, looking at this program, you might think it does 3 things,
but this is not actually the case when it comes to the assembly
that is generated.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://i.imgur.com/64LDU8k.png" alt="64LDU8k.png" />
</p>
</div>
</section>
<section id="slide-org5d84538">
<h3 id="org5d84538">What is in a Program?</h3>
<aside class="notes">
<ul>
<li>In truth, this program is doing many more things when it comes to
talking to the hardware.</li>
<li>First, it sets ups a space in memory for the program to run
in. You will later learn that this is called the stack space.</li>
<li>Then, it allocates a 1 to memory. This takes up 4 bytes in the
stack.</li>
<li>The next line gets more complicated. To us humans programming in
C, it looks like we just say that B is the same thing as A. In
truth though, we are telling the processor to go look up the
memory location of A and move it into a register, and then move
the value of that register into a space in memory - so now we're
actually doing two things.</li>
<li>Having said that, it's probably not surprising that the third
line does even more. First, we need to load both of the pieces of
memory we're referencing into different registers, so that's two
things already. Then, it actually adds the numbers
together. Lastly, it needs to move that calculated value into a
memory register.</li>
<li>This program is significantly more complicated than we probably
assumed, and this is one of the simplest programs we could
possibly write!</li>

</ul>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="https://i.imgur.com/64LDU8k.png" alt="64LDU8k.png" /></td>
<td class="org-left"><img src="https://i.imgur.com/Swoib35.png" alt="Swoib35.png" /></td>
</tr>
</tbody>
</table>
</section>
<section id="slide-orgcd81580">
<h3 id="orgcd81580">What is an Instruction?</h3>
<aside class="notes">
<ul>
<li>But wait&#x2026; there's more! What happens when the processor
executes a single instruction?</li>
<li>You'll have to excuse my hand-drawn diagram here, but I couldn't
find an adequately simple representation of what the insides of a
CPU look like. Sticklers should note that this is a greatly
simplified diagram and that there are a lot of pieces missing.</li>
<li>What you are seeing here is a rough sketch of what we call
Modified Harvard Architecture, the successor to Von Neumann
architecture. It consists of an Arithmetic Logic Unit and a
Control Unit, which are shown in black, a number of registers,
shown in green and red, as well as blocks of memory, shown in
blue. The Control Unit is responsible for managing the bus which
shuffles values around between the various registers and
memory. The registers show here are like tiny pieces of memory
capable of holding one word of memory at a time. The ALU is
responsible for performing operations on the data in green
registers. The red register is the instruction register, which is
responsible for keeping track of where in the program we are, by
storing a pointer to the program's current execution spot in the
program memory. The main memory is there as a place to load and
store values from.</li>
<li>Here's the breakdown of what happens when we run an instruction
like int c = a + b; First, the control unit reads the instruction
from program memory to load the value of A into the data
register, EDX, fetches the value from the appropriate place in
the program memory, and loads it into EDX. Then, the control unit
does the same for the value of B, loading it into the accumulator
register, EAX. Next, the control unit instructs the ALU to add
the registers together, with the result ending up back in the
accumulator register. Lastly, the control unit reads the
instruction to place the result back into program memory, and
copies the value of EAX out to the pointer for the specified
place in program memory.</li>
<li>So, even though we think of programming in C as programming at a
system level, remember that there is a lot going on to still
break down what we're telling the CPU to do, and ultimately the
computer is a rather dumb machine that simply does what it is
told at a very granular level - its power comes from the many
people who came before us and built abstractions making it easier
to solve more and more complex problems as our human brains can
concentrate more on the problem we're trying to solve and less on
the way the computer actually functions.</li>

</ul>

</aside>

<div class="figure">
<p><img src="https://i.imgur.com/QxUxd1p.png" alt="QxUxd1p.png" height="70%" width="70%" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-org0770a54">
<h2 id="org0770a54">Types, Sizes and Why They Matter</h2>
<aside class="notes">
<p>
So, now that we understand memory is complicated and processing is
complicated, it's a bit easier to appreciate some of the seemingly
archaic distinctions C is going to make between different types of
data.
</p>

</aside>
</section>
<section id="slide-org1be1c03">
<h3 id="org1be1c03">Integer types</h3>
<aside class="notes">
<ul>
<li>The types we're going to start working with most from the outset
are integer types, because they are probably the most accessible
to understand.</li>
<li>Most folks find it initially confusing when confronted with C as
to why there are so many different types of what seem to be the
same thing - integers being a primary example.</li>
<li>However, now that we know a bit about how data are stored in
memory, it becomes a little clearer what we're actually telling C
to do when we assign values in code.</li>
<li>The different keywords associated with different data types
actually allocate different amounts and lengths of memory, and
even these can vary from system to system, depending on word
length, address length, and bus size.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >int a = -32767;         /* these are at least 16-bit          */
unsigned int b = 65535;

short c = 32767;        /* also at least 16-bit               */
long d = 2147483647;    /* at least 32-bit                    */

char e = 255;           /* smallest addressable unit - 1 byte */
</code></pre>
</div>
</section>
<section id="slide-org89be076">
<h3 id="org89be076">Characters and ASCII</h3>
<aside class="notes">
<ul>
<li>We already saw we can use the concept of encoding to make the
same set of bits take on special meaning depending on the context
they're interpreted in.</li>
<li>This is exactly how text is handled in C. The values of the char
integer size are mapped to a table called the ASCII table.</li>
<li>While we're not going to be doing much with them today, we'll
soon find out that there is nothing special about strings, but
rather that they are simply consecutively allocated 1-byte chunks
of memory</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >char a = 'a';
char D = 68;
char X = 0x58;
</code></pre>
</div>

<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/875px-ASCII-Table-wide.svg.png" alt="875px-ASCII-Table-wide.svg.png" height="70%" width="70%" background-color="#ffffff" />
</p>
</div>
</section>
<section id="slide-org334fe75">
<h3 id="org334fe75">Floating-point types</h3>
<aside class="notes">
<ul>
<li>There are other types that are defined in the C standard. For
example, floating point numbers.</li>
<li>As we saw in the first section of this talk, by combining
arbitrary sets of bits in order, we can model anything we'd
like.</li>
<li>C takes a lot of the pain out of how processor instructions would
handle allocating memory for data by modeling complicated ideas
for us, such as number with a decimal place, called a float.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >float pi = 3.14159265359;      /* 0x40490FDB =
                          01000000 01001001 00001111 11011011 */
int wat = 1078530011;
float not_pi = -3.14159265359; /* 0xC0490FDB =
                          11000000 01001001 00001111 11011011 */
float pi_high = 314159.265359; /* 0x489965E8 =
                          01001000 10011001 01100101 11101000 */
double pi2 = 3.14159265359;   /* 0x400921FB54442EEA =
                          01000000 00001001 00100001 11111011
                          01010100 01000100 00101110 11101010 */
</code></pre>
</div>
</section>
<section id="slide-org1eb8005">
<h3 id="org1eb8005">Boolean Values</h3>
<aside class="notes">
<ul>
<li>For 30 years, C had no concept of Boolean values. So, if you're
using a language that has weird ideas about what constitutes true
or false, it's probably C's fault.</li>
<li>In C, any non-zero value is considered true, while a 0 value is
considered false.</li>
<li>Because we know any data type is inherently a collection of bits
that may be interpreted as bytes providing an integer, nearly any
predefined type can be evaluated as a Boolean.</li>
<li>Because of this, empty strings evaluate to their value, the
string terminating character 0, and thus are false, while any
other value will evaluate as the first character of the string,
which is inherently non-zero.</li>
<li>In short, while this is a fundamental necessity of the way C
works, be careful as this nuance is likely to continue to trip
you up even as you become an experienced C user.</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="c" >int a = 1;
if (a) { /* executed */
}
a = 0;
if (a) { /* skipped */
}
</code></pre>
</div>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,
margin: 0.20,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
